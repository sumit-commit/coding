/*Brute-force
TC - O(nlogn) + O(n) = O(nlogn)
SC - O(1)

1) First we are sorting the array in ascending order.
2) Once sorted, the largest element will go at the end of the array.
3) Traverse from end of array and compare equality of adjacent elements, till the adjacent elements are same.
4) While traversing, the first unequal element we get will be the second largest.

[8,8,7,6,5] ---after sorting--> [5,6,7,8,8] --> here first non equal element from end is (7) that will be the second largest.
*/

int slargest(vector<int> arr){

  sort(arr.begin(),arr.end());
  for(int i= arr.size()-2 ; i>0 ; i--)
  {
      if(arr[i] != arr[i-1])
      {
        return arr[i-1];
      }
  }
  return -1;
}


/*
Better
TC - O(n) + O(n) = O(2n)
SC - O(1)

1) Here we are running two loops, one for finding largest and next loop for finding second largest.
2) We initialized a variable named (largest) for largest, compared each element with it to find the largest element.
3) We initialized a variable name (slargest) for second largest, traversed through the array, comparing each element with slargest, if arr[i] is greater that slargest and it is not equal to largest element that we found in previous loop, then it can be the second largest, and assign this arr[i] to slargest.
4) at the end of second loop we will have the value of second largest.

[8,8,7,6,5]

*/

int slargest(vector<int> arr)
{
    int largset = arr[0], slargest = -1;
    for(int i=0 ; i<arr.size() ; i++)
    {
        if(arr[i] > largest)
        {
            largest = arr[i];
        }
    }

    for(int i=0 ; i<arr.size() ; i++)
    {
        if(arr[i] > slargest && arr[i] != largest)
        {
            slargest = arr[i];
        }
    }

    return slargest; 
}

/*

Optimal
TC - O(n)
SC - O(1)

Here we are computing largest and second largest by single loop
We initialized largest = arr[0] and slargest = -1 (default value, if second largest not presnt and all same element in array)
In each iteration:
  first case - if current element is greater than largest, it means that element will be largest and the previous {largest} value may become second largest                     slargest.

              if current element is not greater than largest then comes second case,

  second case - if current element is greater than second largest slargest, it can be slargest because it is going closer to largest, but that element should not be equal to largest.

*/
int slargest(vector<int> arr)
{
    int largest = arr[0], slargest = -1;

    for(int i=1 ; i<arr.size() ; i++)
    {
        if(arr[i] > largest)
        {
            slargest = largest;
            largest = arr[i];
        }
        else if(arr[i] > slargest && arr[i] ! largest)
        {
             slargest = arr[i ;          
        }
    }
    return slargest;
}
