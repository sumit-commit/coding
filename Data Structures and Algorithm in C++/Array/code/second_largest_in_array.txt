/*Brute-force
TC - O(nlogn) + O(n) = O(nlogn)
SC - O(1)

1) First we are sorting the array in ascending order.
2) Once sorted, the largest element will go at the end of the array.
3) Traverse from back the first, till the adjacent elements are same.
4) While traversing, the first unequal element we get will be the second largest.

[8,8,7,6,5] ---after sorting--> [5,6,7,8,8] --> here first non equal element from end is (7) that will be the second largest.

*/
int slargest(vector<int> arr){

  sort(arr.begin(),arr.end());
  for(int i= arr.size()-2 ; i>0 ; i--)
  {
      if(arr[i] != arr[i-1])
      {
        return arr[i-1];
      }
  }
  return -1;
}


//Better
//TC - O(n) + O(n) = O(2n)
//SC - O(1)

int slargest(vector<int> arr)
{
    int largset = arr[0], slargest = -1;
    for(int i=0 ; i<arr.size() ; i++)
    {
        if(arr[i] > largest)
        {
            largest = arr[i];
        }
    }

    for(int i=0 ; i<arr.size() ; i++)
    {
        if(arr[i] > slargest && arr[i] != largest)
        {
            slargest = arr[i];
        }
    }

    return slargest;
}

//Optimal
//TC - O(n)
//SC - O(1)

int slargest(vector<int> arr)
{
    int largest = arr[0], slargest = -1;

    for(int i=1 ; i<arr.size() ; i++)
    {
        if(arr[i] > largest)
        {
            slargest = largest;
            largest = arr[i];
        }
        else if(arr[i] > slargest && arr[i] ! largest)
        {
             slargest = arr[i ;          
        }
    }
    return slargest;
}
